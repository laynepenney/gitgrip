//! PR merge command implementation

use crate::cli::output::Output;
use crate::core::manifest::Manifest;
use crate::core::repo::RepoInfo;
use crate::git::{get_current_branch, open_repo, path_exists};
use crate::platform::traits::PlatformError;
use crate::platform::{detect_platform, get_platform_adapter, CheckState, MergeMethod};
use std::path::PathBuf;
use std::sync::Arc;

/// Run the PR merge command
pub async fn run_pr_merge(
    workspace_root: &PathBuf,
    manifest: &Manifest,
    method: Option<&str>,
    force: bool,
    update: bool,
    auto: bool,
) -> anyhow::Result<()> {
    Output::header("Merging pull requests...");
    println!();

    let repos: Vec<RepoInfo> = manifest
        .repos
        .iter()
        .filter_map(|(name, config)| RepoInfo::from_config(name, config, workspace_root))
        .filter(|r| !r.reference) // Skip reference repos
        .collect();

    let merge_method = match method {
        Some("squash") => MergeMethod::Squash,
        Some("rebase") => MergeMethod::Rebase,
        _ => MergeMethod::Merge,
    };

    // Also check manifest repo if configured
    let mut all_repos = repos.clone();
    if let Some(manifest_config) = &manifest.manifest {
        let manifests_dir = workspace_root.join(".gitgrip/manifests");
        if let Some(manifest_repo) =
            create_manifest_repo_info(manifest_config, &manifests_dir, workspace_root)
        {
            // Only add manifest repo if it has changes
            match check_repo_for_changes(&manifest_repo) {
                Ok(true) => {
                    all_repos.push(manifest_repo);
                }
                Ok(false) => {
                    Output::info("manifest: no changes, skipping");
                }
                Err(e) => {
                    Output::warning(&format!("manifest: could not check for changes: {}", e));
                }
            }
        }
    }

    // Collect PRs to merge
    #[derive(Debug, Clone, Copy)]
    enum CheckStatus {
        Passing,
        Failing,
        Pending,
        Unknown,
    }

    struct PRToMerge {
        repo_name: String,
        owner: String,
        repo: String,
        pr_number: u64,
        platform: Arc<dyn crate::platform::HostingPlatform>,
        approved: bool,
        check_status: CheckStatus,
        mergeable: bool,
    }

    let mut prs_to_merge: Vec<PRToMerge> = Vec::new();

    for repo in &all_repos {
        if !path_exists(&repo.absolute_path) {
            continue;
        }

        let git_repo = match open_repo(&repo.absolute_path) {
            Ok(r) => r,
            Err(_) => continue,
        };

        let branch = match get_current_branch(&git_repo) {
            Ok(b) => b,
            Err(_) => continue,
        };

        // Skip if on default branch
        if branch == repo.default_branch {
            continue;
        }

        let platform_type = detect_platform(&repo.url);
        let platform = get_platform_adapter(platform_type, None);

        match platform
            .find_pr_by_branch(&repo.owner, &repo.repo, &branch)
            .await
        {
            Ok(Some(pr)) => {
                // Get PR details
                let (approved, mergeable) = match platform
                    .get_pull_request(&repo.owner, &repo.repo, pr.number)
                    .await
                {
                    Ok(full_pr) => {
                        let is_approved = platform
                            .is_pull_request_approved(&repo.owner, &repo.repo, pr.number)
                            .await
                            .unwrap_or(false);
                        (is_approved, full_pr.mergeable.unwrap_or(false))
                    }
                    Err(_) => (false, false),
                };

                // Get status checks
                let check_status = match platform
                    .get_status_checks(&repo.owner, &repo.repo, &branch)
                    .await
                {
                    Ok(status) => {
                        // Successfully got check status
                        if status.state == CheckState::Failure {
                            // Checks are actually failing
                            CheckStatus::Failing
                        } else if status.state == CheckState::Pending {
                            // Checks still running - don't block but warn
                            CheckStatus::Pending
                        } else {
                            CheckStatus::Passing
                        }
                    }
                    Err(e) => {
                        // Could not determine check status
                        // Don't block merge due to API issues
                        Output::warning(&format!(
                            "{}: Could not check CI status for PR #{}: {}",
                            repo.name, pr.number, e
                        ));
                        CheckStatus::Unknown
                    }
                };

                prs_to_merge.push(PRToMerge {
                    repo_name: repo.name.clone(),
                    owner: repo.owner.clone(),
                    repo: repo.repo.clone(),
                    pr_number: pr.number,
                    platform,
                    approved,
                    check_status,
                    mergeable,
                });
            }
            Ok(None) => {
                Output::info(&format!("{}: no open PR for this branch", repo.name));
            }
            Err(e) => {
                Output::error(&format!("{}: {}", repo.name, e));
            }
        }
    }

    if prs_to_merge.is_empty() {
        println!("No open PRs found for any repository.");
        println!("Repositories checked: {}", all_repos.len());
        return Ok(());
    }

    // Show which repos have PRs and which don't
    let repos_with_prs: Vec<String> = prs_to_merge.iter().map(|p| p.repo_name.clone()).collect();
    let repos_without_prs: Vec<String> = all_repos
        .iter()
        .filter(|r| !repos_with_prs.contains(&r.name))
        .map(|r| r.name.clone())
        .collect();

    if !repos_without_prs.is_empty() {
        Output::info(&format!(
            "Merging {} repo(s) with open PRs. {} repo(s) have no open PRs and will be skipped.",
            prs_to_merge.len(),
            repos_without_prs.len()
        ));
        for repo_name in &repos_without_prs {
            Output::info(&format!("  - {}: skipped (no open PR)", repo_name));
        }
        println!();
    }

    // Check readiness if not forcing
    if !force {
        let mut issues = Vec::new();
        for pr in &prs_to_merge {
            if !pr.approved {
                issues.push(format!(
                    "{} PR #{}: not approved",
                    pr.repo_name, pr.pr_number
                ));
            }
            match pr.check_status {
                CheckStatus::Failing => {
                    issues.push(format!(
                        "{} PR #{}: checks failing",
                        pr.repo_name, pr.pr_number
                    ));
                }
                CheckStatus::Pending => {
                    issues.push(format!(
                        "{} PR #{}: checks still running",
                        pr.repo_name, pr.pr_number
                    ));
                }
                CheckStatus::Unknown => {
                    // Don't block on unknown - warn but allow merge
                    Output::warning(&format!(
                        "{} PR #{}: check status unknown - proceeding with caution",
                        pr.repo_name, pr.pr_number
                    ));
                }
                CheckStatus::Passing => {} // All good
            }
            if !pr.mergeable {
                issues.push(format!(
                    "{} PR #{}: not mergeable (branch may be behind base â€” try --update)",
                    pr.repo_name, pr.pr_number
                ));
            }
        }

        if !issues.is_empty() {
            Output::warning("Some PRs have issues:");
            for issue in &issues {
                println!("  - {}", issue);
            }
            println!();
            println!("Use --force to merge anyway.");
            return Ok(());
        }
    }

    // Auto-merge flow: enable auto-merge and return early
    if auto {
        let mut success_count = 0;
        let mut error_count = 0;

        for pr in prs_to_merge {
            let spinner = Output::spinner(&format!(
                "Enabling auto-merge for {} PR #{}...",
                pr.repo_name, pr.pr_number
            ));

            match pr
                .platform
                .enable_auto_merge(&pr.owner, &pr.repo, pr.pr_number, Some(merge_method))
                .await
            {
                Ok(true) => {
                    spinner.finish_with_message(format!(
                        "{}: PR #{} will auto-merge when checks pass",
                        pr.repo_name, pr.pr_number
                    ));
                    success_count += 1;
                }
                Ok(false) => {
                    spinner.finish_with_message(format!(
                        "{}: PR #{} auto-merge could not be enabled",
                        pr.repo_name, pr.pr_number
                    ));
                    error_count += 1;
                }
                Err(e) => {
                    spinner.finish_with_message(format!("{}: failed - {}", pr.repo_name, e));
                    error_count += 1;
                }
            }
        }

        println!();
        if error_count == 0 {
            Output::success(&format!(
                "Auto-merge enabled for {} PR(s). They will merge when all checks pass.",
                success_count
            ));
        } else {
            Output::warning(&format!(
                "{} auto-merge enabled, {} failed",
                success_count, error_count
            ));
        }

        return Ok(());
    }

    // Merge PRs
    let mut success_count = 0;
    let mut error_count = 0;

    for pr in prs_to_merge {
        let spinner = Output::spinner(&format!("Merging {} PR #{}...", pr.repo_name, pr.pr_number));

        let merge_result = pr
            .platform
            .merge_pull_request(
                &pr.owner,
                &pr.repo,
                pr.pr_number,
                Some(merge_method),
                true, // delete branch
            )
            .await;

        // Handle BranchBehind with --update retry
        let merge_result = match merge_result {
            Err(PlatformError::BranchBehind(ref msg)) if update => {
                spinner.finish_with_message(format!(
                    "{}: branch behind base, updating...",
                    pr.repo_name
                ));
                let update_spinner = Output::spinner(&format!(
                    "Updating {} PR #{} branch...",
                    pr.repo_name, pr.pr_number
                ));

                match pr
                    .platform
                    .update_branch(&pr.owner, &pr.repo, pr.pr_number)
                    .await
                {
                    Ok(true) => {
                        update_spinner.finish_with_message(format!(
                            "{}: branch updated, waiting for merge...",
                            pr.repo_name
                        ));
                        // Wait for GitHub to process the update
                        tokio::time::sleep(std::time::Duration::from_secs(3)).await;

                        // Retry merge
                        pr.platform
                            .merge_pull_request(
                                &pr.owner,
                                &pr.repo,
                                pr.pr_number,
                                Some(merge_method),
                                true,
                            )
                            .await
                    }
                    Ok(false) => {
                        update_spinner.finish_with_message(format!(
                            "{}: branch already up to date",
                            pr.repo_name
                        ));
                        Err(PlatformError::BranchBehind(msg.clone()))
                    }
                    Err(update_err) => {
                        update_spinner.finish_with_message(format!(
                            "{}: branch update failed - {}",
                            pr.repo_name, update_err
                        ));
                        Err(PlatformError::BranchBehind(msg.clone()))
                    }
                }
            }
            other => other,
        };

        match merge_result {
            Ok(merged) => {
                if merged {
                    spinner.finish_with_message(format!(
                        "{}: merged PR #{}",
                        pr.repo_name, pr.pr_number
                    ));
                    success_count += 1;
                } else {
                    spinner.finish_with_message(format!(
                        "{}: PR #{} was already merged",
                        pr.repo_name, pr.pr_number
                    ));
                    success_count += 1;
                }
            }
            Err(PlatformError::BranchBehind(_)) => {
                spinner.finish_with_message(format!(
                    "{}: PR #{} branch is behind base branch",
                    pr.repo_name, pr.pr_number
                ));
                Output::info("  Hint: use 'gr pr merge --update' to update the branch and retry");
                error_count += 1;
            }
            Err(PlatformError::BranchProtected(ref msg)) => {
                spinner.finish_with_message(format!("{}: {}", pr.repo_name, msg));
                Output::info(
                    "  Hint: use 'gr pr merge --auto' to enable auto-merge when checks pass",
                );
                Output::info(&format!(
                    "  Or:   gh pr merge {} --admin --repo {}/{}",
                    pr.pr_number, pr.owner, pr.repo
                ));
                error_count += 1;
            }
            Err(e) => {
                spinner.finish_with_message(format!("{}: failed - {}", pr.repo_name, e));
                error_count += 1;

                // Check for all-or-nothing merge strategy (unless forcing)
                if !force
                    && manifest.settings.merge_strategy
                        == crate::core::manifest::MergeStrategy::AllOrNothing
                {
                    Output::error(
                        "Stopping due to all-or-nothing merge strategy. Use --force to bypass.",
                    );
                    return Err(e.into());
                }
                // If forcing with AllOrNothing, just log and continue
                if force
                    && manifest.settings.merge_strategy
                        == crate::core::manifest::MergeStrategy::AllOrNothing
                {
                    Output::warning(&format!(
                        "{}: merge failed but continuing due to --force flag",
                        pr.repo_name
                    ));
                }
            }
        }
    }

    // Summary
    println!();
    if error_count == 0 {
        Output::success(&format!("Successfully merged {} PR(s).", success_count));
    } else {
        Output::warning(&format!("{} merged, {} failed", success_count, error_count));
    }

    Ok(())
}

/// Create RepoInfo for the manifest repository
fn create_manifest_repo_info(
    config: &crate::core::manifest::ManifestRepoConfig,
    _manifests_dir: &PathBuf,
    workspace_root: &PathBuf,
) -> Option<RepoInfo> {
    let path = ".gitgrip/manifests".to_string();

    crate::core::repo::RepoInfo::from_config(
        "manifest",
        &crate::core::manifest::RepoConfig {
            url: config.url.clone(),
            path,
            default_branch: config.default_branch.clone(),
            copyfile: config.copyfile.clone(),
            linkfile: config.linkfile.clone(),
            platform: config.platform.clone(),
            reference: false,
            groups: Vec::new(),
        },
        workspace_root,
    )
}

/// Check if a repo has changes ahead of its default branch
/// Returns Ok(true) if there are changes, Ok(false) if no changes or on default branch
fn check_repo_for_changes(repo: &RepoInfo) -> anyhow::Result<bool> {
    let git_repo = open_repo(&repo.absolute_path)
        .map_err(|e| anyhow::anyhow!("Failed to open repo: {}", e))?;

    let current = get_current_branch(&git_repo)
        .map_err(|e| anyhow::anyhow!("Failed to get current branch: {}", e))?;

    // Skip if on default branch
    if current == repo.default_branch {
        return Ok(false);
    }

    // Check if current branch has commits ahead of default
    let local_branch = git_repo
        .find_branch(&current, git2::BranchType::Local)
        .map_err(|e| anyhow::anyhow!("Failed to find local branch: {}", e))?;

    let local_ref = local_branch
        .get()
        .peel_to_commit()
        .map_err(|e| anyhow::anyhow!("Failed to peel to commit: {}", e))?;

    let default_branch = git_repo
        .find_branch(&repo.default_branch, git2::BranchType::Local)
        .map_err(|e| {
            anyhow::anyhow!(
                "Failed to find default branch '{}': {}",
                repo.default_branch,
                e
            )
        })?;

    let default_ref = default_branch
        .get()
        .peel_to_commit()
        .map_err(|e| anyhow::anyhow!("Failed to peel default to commit: {}", e))?;

    // Check if local is ahead of default (has unique commits)
    match git_repo.graph_ahead_behind(local_ref.id(), default_ref.id()) {
        Ok((ahead, _behind)) => Ok(ahead > 0),
        Err(e) => Err(anyhow::anyhow!("Failed to compare branches: {}", e)),
    }
}
