//! Repository information and operations

use std::path::{Path, PathBuf};

use crate::core::manifest::{Manifest, ManifestRepoConfig, PlatformType, RepoConfig};

/// Extended repository information with computed fields
#[derive(Debug, Clone)]
pub struct RepoInfo {
    /// Repository name (from manifest key)
    pub name: String,
    /// Git URL (SSH or HTTPS)
    pub url: String,
    /// Local path relative to manifest root
    pub path: String,
    /// Absolute path on disk
    pub absolute_path: PathBuf,
    /// Default branch (e.g., "main", "master")
    pub default_branch: String,
    /// Owner/namespace from git URL
    pub owner: String,
    /// Repo name from git URL
    pub repo: String,
    /// Detected or configured platform type
    pub platform_type: PlatformType,
    /// Project name (Azure DevOps only)
    pub project: Option<String>,
    /// Reference repo (read-only, excluded from branch/PR operations)
    pub reference: bool,
    /// Groups this repo belongs to (for selective operations)
    pub groups: Vec<String>,
}

impl RepoInfo {
    /// Create RepoInfo from a manifest RepoConfig
    pub fn from_config(name: &str, config: &RepoConfig, workspace_root: &PathBuf) -> Option<Self> {
        let parsed = parse_git_url(&config.url)?;

        let absolute_path = workspace_root.join(&config.path);

        let platform_type = config
            .platform
            .as_ref()
            .map(|p| p.platform_type)
            .unwrap_or_else(|| detect_platform(&config.url));

        Some(Self {
            name: name.to_string(),
            url: config.url.clone(),
            path: config.path.clone(),
            absolute_path,
            default_branch: config.default_branch.clone(),
            owner: parsed.owner,
            repo: parsed.repo,
            platform_type,
            project: parsed.project,
            reference: config.reference,
            groups: config.groups.clone(),
        })
    }

    /// Check if the repository exists on disk
    pub fn exists(&self) -> bool {
        self.absolute_path.join(".git").exists()
    }
}

/// Parsed git URL components
struct ParsedUrl {
    owner: String,
    repo: String,
    project: Option<String>,
}

/// Parse a git URL to extract owner and repo
fn parse_git_url(url: &str) -> Option<ParsedUrl> {
    // Handle SSH URLs: git@github.com:owner/repo.git
    if url.starts_with("git@") {
        let parts: Vec<&str> = url.splitn(2, ':').collect();
        if parts.len() != 2 {
            return None;
        }
        let path = parts[1].trim_end_matches(".git");

        // Handle Azure DevOps SSH: git@ssh.dev.azure.com:v3/org/project/repo
        if url.contains("dev.azure.com") || url.contains("visualstudio.com") {
            let segments: Vec<&str> = path.split('/').collect();
            if segments.len() >= 4 && segments[0] == "v3" {
                return Some(ParsedUrl {
                    owner: segments[1].to_string(),
                    repo: segments[3].to_string(),
                    project: Some(segments[2].to_string()),
                });
            }
        }

        // Standard format: owner/repo
        let segments: Vec<&str> = path.split('/').collect();
        if segments.len() >= 2 {
            return Some(ParsedUrl {
                owner: segments[0].to_string(),
                repo: segments[segments.len() - 1].to_string(),
                project: None,
            });
        }
    }

    // Handle HTTPS URLs: https://github.com/owner/repo.git
    if url.starts_with("https://") || url.starts_with("http://") {
        let url_without_proto = url
            .trim_start_matches("https://")
            .trim_start_matches("http://");
        let path = url_without_proto
            .split_once('/')?
            .1
            .trim_end_matches(".git");

        // Handle Azure DevOps HTTPS: https://dev.azure.com/org/project/_git/repo
        if url.contains("dev.azure.com") {
            let segments: Vec<&str> = path.split('/').collect();
            if segments.len() >= 4 && segments[2] == "_git" {
                return Some(ParsedUrl {
                    owner: segments[0].to_string(),
                    repo: segments[3].to_string(),
                    project: Some(segments[1].to_string()),
                });
            }
        }

        // Handle visualstudio.com: https://org.visualstudio.com/project/_git/repo
        if url.contains("visualstudio.com") {
            // Extract org from subdomain
            let host_and_path: Vec<&str> = url_without_proto.splitn(2, '/').collect();
            if host_and_path.len() < 2 {
                return None;
            }
            let host = host_and_path[0];
            let org = host.split('.').next()?;
            let segments: Vec<&str> = path.split('/').collect();
            if segments.len() >= 3 && segments[1] == "_git" {
                return Some(ParsedUrl {
                    owner: org.to_string(),
                    repo: segments[2].to_string(),
                    project: Some(segments[0].to_string()),
                });
            }
        }

        // Standard format: owner/repo
        let segments: Vec<&str> = path.split('/').collect();
        if segments.len() >= 2 {
            return Some(ParsedUrl {
                owner: segments[0].to_string(),
                repo: segments[segments.len() - 1].to_string(),
                project: None,
            });
        }
    }

    // Handle file:// URLs (used in testing with local bare repos)
    if url.starts_with("file://") {
        let path = url.trim_start_matches("file://").trim_end_matches(".git");
        // Extract the last path component as repo name
        if let Some(name) = path.rsplit('/').next() {
            return Some(ParsedUrl {
                owner: "local".to_string(),
                repo: name.to_string(),
                project: None,
            });
        }
    }

    None
}

/// Filter repos from a manifest by name, group, and reference status.
///
/// Replaces the repeated `.iter().filter_map().filter().filter().collect()` pattern
/// found across commands.
pub fn filter_repos(
    manifest: &Manifest,
    workspace_root: &PathBuf,
    repos_filter: Option<&[String]>,
    group_filter: Option<&[String]>,
    include_reference: bool,
) -> Vec<RepoInfo> {
    manifest
        .repos
        .iter()
        .filter_map(|(name, config)| RepoInfo::from_config(name, config, workspace_root))
        .filter(|r| include_reference || !r.reference)
        .filter(|r| {
            repos_filter
                .map(|filter| filter.iter().any(|f| f == &r.name))
                .unwrap_or(true)
        })
        .filter(|r| {
            group_filter
                .map(|groups| r.groups.iter().any(|g| groups.contains(g)))
                .unwrap_or(true)
        })
        .collect()
}

/// Get RepoInfo for the manifest repo if it exists.
///
/// This provides a standardized way to include the manifest repository
/// in operations like sync, branch, checkout, push, and diff.
pub fn get_manifest_repo_info(manifest: &Manifest, workspace_root: &Path) -> Option<RepoInfo> {
    let manifest_config = manifest.manifest.as_ref()?;
    let manifests_dir = workspace_root.join(".gitgrip").join("manifests");

    // Only return if the manifest repo actually exists as a git repo
    if !manifests_dir.join(".git").exists() {
        return None;
    }

    create_manifest_repo_info(manifest_config, workspace_root)
}

/// Create RepoInfo from ManifestRepoConfig
fn create_manifest_repo_info(
    config: &ManifestRepoConfig,
    workspace_root: &Path,
) -> Option<RepoInfo> {
    let path = ".gitgrip/manifests".to_string();

    RepoInfo::from_config(
        "manifest",
        &RepoConfig {
            url: config.url.clone(),
            path,
            default_branch: config.default_branch.clone(),
            copyfile: config.copyfile.clone(),
            linkfile: config.linkfile.clone(),
            platform: config.platform.clone(),
            reference: false,
            groups: Vec::new(),
        },
        &workspace_root.to_path_buf(),
    )
}

/// Detect platform type from URL
fn detect_platform(url: &str) -> PlatformType {
    // Check GitHub first (most common)
    if url.contains("github.com") {
        return PlatformType::GitHub;
    }

    // Check Azure DevOps before GitLab (avoid false positives)
    if url.contains("dev.azure.com") || url.contains("visualstudio.com") {
        return PlatformType::AzureDevOps;
    }

    // Check Bitbucket before GitLab
    if url.contains("bitbucket.org") || url.contains("bitbucket.") {
        return PlatformType::Bitbucket;
    }

    // Check GitLab - ensure it's in hostname, not just path
    if url.contains("gitlab.com") || url.contains("gitlab.") {
        return PlatformType::GitLab;
    }

    // Default to GitHub for backward compatibility
    PlatformType::GitHub
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_github_ssh() {
        let parsed = parse_git_url("git@github.com:user/repo.git").unwrap();
        assert_eq!(parsed.owner, "user");
        assert_eq!(parsed.repo, "repo");
        assert!(parsed.project.is_none());
    }

    #[test]
    fn test_parse_github_https() {
        let parsed = parse_git_url("https://github.com/user/repo.git").unwrap();
        assert_eq!(parsed.owner, "user");
        assert_eq!(parsed.repo, "repo");
    }

    #[test]
    fn test_parse_azure_https() {
        let parsed = parse_git_url("https://dev.azure.com/org/project/_git/repo").unwrap();
        assert_eq!(parsed.owner, "org");
        assert_eq!(parsed.repo, "repo");
        assert_eq!(parsed.project, Some("project".to_string()));
    }

    #[test]
    fn test_parse_azure_ssh() {
        let parsed = parse_git_url("git@ssh.dev.azure.com:v3/org/project/repo").unwrap();
        assert_eq!(parsed.owner, "org");
        assert_eq!(parsed.repo, "repo");
        assert_eq!(parsed.project, Some("project".to_string()));
    }

    #[test]
    fn test_parse_file_url() {
        let parsed = parse_git_url("file:///tmp/remotes/myrepo.git").unwrap();
        assert_eq!(parsed.owner, "local");
        assert_eq!(parsed.repo, "myrepo");
        assert!(parsed.project.is_none());
    }

    #[test]
    fn test_parse_file_url_no_extension() {
        let parsed = parse_git_url("file:///tmp/repos/test-repo").unwrap();
        assert_eq!(parsed.owner, "local");
        assert_eq!(parsed.repo, "test-repo");
    }

    #[test]
    fn test_detect_github() {
        assert_eq!(
            detect_platform("git@github.com:user/repo.git"),
            PlatformType::GitHub
        );
    }

    #[test]
    fn test_detect_gitlab() {
        assert_eq!(
            detect_platform("git@gitlab.com:user/repo.git"),
            PlatformType::GitLab
        );
    }

    #[test]
    fn test_detect_azure() {
        assert_eq!(
            detect_platform("https://dev.azure.com/org/project/_git/repo"),
            PlatformType::AzureDevOps
        );
    }

    #[test]
    fn test_get_manifest_repo_info_no_manifest() {
        use crate::core::manifest::Manifest;
        use std::collections::HashMap;
        use tempfile::TempDir;

        let temp = TempDir::new().unwrap();
        let manifest = Manifest {
            version: 1,
            manifest: None,
            repos: HashMap::new(),
            settings: Default::default(),
            workspace: None,
        };

        let result = get_manifest_repo_info(&manifest, temp.path());
        assert!(result.is_none());
    }

    #[test]
    fn test_get_manifest_repo_info_no_git_dir() {
        use crate::core::manifest::{Manifest, ManifestRepoConfig};
        use std::collections::HashMap;
        use tempfile::TempDir;

        let temp = TempDir::new().unwrap();
        let manifest = Manifest {
            version: 1,
            manifest: Some(ManifestRepoConfig {
                url: "git@github.com:user/manifest.git".to_string(),
                default_branch: "main".to_string(),
                copyfile: None,
                linkfile: None,
                platform: None,
            }),
            repos: HashMap::new(),
            settings: Default::default(),
            workspace: None,
        };

        // No .gitgrip/manifests/.git directory exists
        let result = get_manifest_repo_info(&manifest, temp.path());
        assert!(result.is_none());
    }

    #[test]
    fn test_get_manifest_repo_info_with_git_dir() {
        use crate::core::manifest::{Manifest, ManifestRepoConfig};
        use std::collections::HashMap;
        use std::fs;
        use tempfile::TempDir;

        let temp = TempDir::new().unwrap();

        // Create .gitgrip/manifests/.git directory
        let manifests_dir = temp.path().join(".gitgrip").join("manifests");
        fs::create_dir_all(manifests_dir.join(".git")).unwrap();

        let manifest = Manifest {
            version: 1,
            manifest: Some(ManifestRepoConfig {
                url: "git@github.com:user/manifest.git".to_string(),
                default_branch: "main".to_string(),
                copyfile: None,
                linkfile: None,
                platform: None,
            }),
            repos: HashMap::new(),
            settings: Default::default(),
            workspace: None,
        };

        let result = get_manifest_repo_info(&manifest, temp.path());
        assert!(result.is_some());

        let info = result.unwrap();
        assert_eq!(info.name, "manifest");
        assert_eq!(info.path, ".gitgrip/manifests");
        assert_eq!(info.default_branch, "main");
        assert!(!info.reference);
    }
}
